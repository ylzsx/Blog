## Java内存模型中的性质

- 可见性
  - 通常，我们无法确保执行读操作的线程能够实时地看到其他线程写入的值，为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。
  - 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。
  - 用`volatile`修饰的变量具有可见性。其修饰的变量不允许线程内部缓存和重排序，但`volatile`修饰的变量不能保证原子性。
  - java中通过`synchronized`和`volatile`、`final`保证可见性。

- 原子性
  - 原子性指的是操作是不可分割的（比如：`a=0`, a非`long`和`double`类型。然而`a++`就可以分为`a=a+1`，故其不是原子操作）。
  - 非原子操作会带来线程安全问题，可以使用同步技术(`sychronized`)使其转变为原子操作。
  - java的`concurrent`包下提供了一些原子类，如`AtomicInteger`、`AtomicLong`、`AtomicReference`。
  - java中通过`synchronized`和`lock`、`unlock`保证原子性。
- 有序性
  - Java语言提供了`volatile`和`synchronized`两个关键字来保证线程之间操作的有序性。
  - `volatile `是因其本身包含“禁止指令重排序”的语义，`synchronized`是由“一个变量在同一个时刻只允许一条线程对其进行` lock `操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

## volatile

`volatile`可以保证可见性和有序性，但不能保证原子性。

### 实现原理

#### 可见性实现

- `volatile`变量的可见性是基于**内存屏障**实现。

  - 内存屏障，又称内存栅栏，是一个CPU指令。
  - 在程序运行时。为了提高性能，编译器和处理器会对指令进行重排序，JMM【JMM 定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式】为了保证在不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条内存屏障指令重排序。
  - 为了提高处理速度，处理器一般不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不确定何时会写到内存。但是如果对声明了 `volatile`的变量进行写操作，JVM 就会向处理器发送一条`lock`前缀的指令，将这个变量所在缓存行的数据写回到系统内存。
  - 而为了保证各个处理器的缓存是一致的，实现了缓存一致性协议（MESI），每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

##### lock指令

​	在早期处理器中，`lock`前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。而因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 这种场景多缓存的数据一致通过缓存一致性协议（MESI）来保证。